#include "unity.h"

#include "cobs.h"

static void test_encode(
        const uint8_t *input_data, uint32_t input_length,
        const uint8_t *expected_data, uint32_t expected_length);
static void test_decode(
        const uint8_t *expected_data, uint32_t expected_length,
        const uint8_t *input_data, uint32_t input_length);

/******************************************************************************
 * Test Data
 ******************************************************************************/

const uint8_t SHORT_DATA_NO_ZEROS[] = {
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
};

const uint8_t SHORT_DATA_NO_ZEROS_ENCODED[] = {
    0x09, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
//  ^
//  Added 0x09 byte since there are 8 bytes of data, and no other control bytes.
//  The last control byte (in this case the only one) is always equal to
//  remaining length + 1.
};

const uint8_t SHORT_DATA_ONE_ZERO[] = {
          0xAB, 0xCD, 0xEF, 0x12, 0x00, 0x56, 0x78, 0x90,
};

const uint8_t SHORT_DATA_ONE_ZERO_ENCODED[] = {
    0x05, 0xAB, 0xCD, 0xEF, 0x12, 0x04, 0x56, 0x78, 0x90,
//  ^                             ^
// 0x05 Byte added to beginning since the next control byte is 5 bytes away.
// 0x04 Byte replaced 0x00.  It's the last control byte, so its value is equal
// to remaining length + 1.
};

const uint8_t MEDIUM_DATA_SEVERAL_ZEROS[] = {
          0xAB, 0xCD, 0x00, 0x12, 0x00, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x05, 0x00, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x00, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x00, 0x56, 0x00, 0x00,
};

const uint8_t MEDIUM_DATA_SEVERAL_ZEROS_ENCODED[] = {
    0x03, 0xAB, 0xCD, 0x02, 0x12, 0x09, 0x56, 0x78, 0x90,
//  ^                 ^           ^
          0xAB, 0xCD, 0xEF, 0x12, 0x05, 0x07, 0x78, 0x90,
//                                      ^
          0xAB, 0xCD, 0xEF, 0x12, 0x08, 0x56, 0x78, 0x90,
//                                ^
          0xAB, 0xCD, 0xEF, 0x12, 0x02, 0x56, 0x01, 0x01,
//                                ^           ^     ^
};

const uint8_t LONG_DATA_NO_ZEROS[] = {
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78,
};

const uint8_t LONG_DATA_NO_ZEROS_ENCODED[] = {
    0xFF, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
//  ^
// Added 0xFF byte, since there are more than 254 bytes before the next zero.
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x02, 0x78,
//                                            ^
// Added 0x02 byte since there is one byte remaining, and last control byte is
// always remaining length + 1
};

const uint8_t EXTRA_LONG_DATA_NO_ZEROS[] = {
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, // 254 Bytes

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, // 508 Bytes
};

const uint8_t EXTRA_LONG_DATA_NO_ZEROS_ENCODED [] = {
    0xFF, 0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
//  ^
// No zeros for next 254 bytes, so first control byte is 0xFF
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0xFF,
//                                            ^
// Inserted overhead byte, since there were no zeros in the last 254 bytes.
// Value is 0xFF since there are no zeros in the next 254 bytes either.

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,

          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56, 0x78, 0x90,
          0xAB, 0xCD, 0xEF, 0x12, 0x34, 0x56,
};

const uint8_t INVALID_ENCODING[] = {
    0x04, 0xAB, 0xCD, 0xEF, 0x06, 0x07, 0x56, 0x78, 0x90,
//  ^                       ^
// First byte specifies the next control byte four positions later.  At that
// position, the value 0x06 says to expect the next one after 6 more bytes (or
// the end of the data), but the data ends after only 5 bytes, making the
// encoding invalid.
};

/******************************************************************************
 * Setup / Teardown
 ******************************************************************************/

void setUp(void)
{
}

void tearDown(void)
{
}

/******************************************************************************
 * Size Macros
 ******************************************************************************/

void test_encode_length_macro(void)
{
    TEST_ASSERT_EQUAL_INT(2, COBS_MAX_DATA_LENGTH_AFTER_ENCODE(1));
    TEST_ASSERT_EQUAL_INT(255, COBS_MAX_DATA_LENGTH_AFTER_ENCODE(254));
    TEST_ASSERT_EQUAL_INT(257, COBS_MAX_DATA_LENGTH_AFTER_ENCODE(255));
    TEST_ASSERT_EQUAL_INT(510, COBS_MAX_DATA_LENGTH_AFTER_ENCODE(508));
    TEST_ASSERT_EQUAL_INT(512, COBS_MAX_DATA_LENGTH_AFTER_ENCODE(509));
}

void test_decode_length_macro(void)
{
    TEST_ASSERT_EQUAL_INT(1, COBS_MAX_DATA_LENGTH_AFTER_DECODE(2));
    TEST_ASSERT_EQUAL_INT(255, COBS_MAX_DATA_LENGTH_AFTER_DECODE(256));
}

/******************************************************************************
 * COBS Encode
 ******************************************************************************/

void test_encode_short_data_no_zeros(void)
{
    test_encode(
            SHORT_DATA_NO_ZEROS,
            sizeof(SHORT_DATA_NO_ZEROS),
            SHORT_DATA_NO_ZEROS_ENCODED,
            sizeof(SHORT_DATA_NO_ZEROS_ENCODED));
}

void test_encode_short_data_one_zero(void)
{
    test_encode(
            SHORT_DATA_ONE_ZERO,
            sizeof(SHORT_DATA_ONE_ZERO),
            SHORT_DATA_ONE_ZERO_ENCODED,
            sizeof(SHORT_DATA_ONE_ZERO_ENCODED));
}

void test_encode_medium_data_several_zeros(void)
{
    test_encode(
            MEDIUM_DATA_SEVERAL_ZEROS,
            sizeof(MEDIUM_DATA_SEVERAL_ZEROS),
            MEDIUM_DATA_SEVERAL_ZEROS_ENCODED,
            sizeof(MEDIUM_DATA_SEVERAL_ZEROS_ENCODED));
}

void test_encode_long_data_no_zeros(void)
{
    test_encode(
            LONG_DATA_NO_ZEROS,
            sizeof(LONG_DATA_NO_ZEROS),
            LONG_DATA_NO_ZEROS_ENCODED,
            sizeof(LONG_DATA_NO_ZEROS_ENCODED));
}

void test_encode_extra_long_data_no_zeros(void)
{
    test_encode(
            EXTRA_LONG_DATA_NO_ZEROS,
            sizeof(EXTRA_LONG_DATA_NO_ZEROS),
            EXTRA_LONG_DATA_NO_ZEROS_ENCODED,
            sizeof(EXTRA_LONG_DATA_NO_ZEROS_ENCODED));
}


/******************************************************************************
 * COBS Decode
 ******************************************************************************/

void test_decode_short_data_no_zeros(void)
{
    test_decode(
            SHORT_DATA_NO_ZEROS,
            sizeof(SHORT_DATA_NO_ZEROS),
            SHORT_DATA_NO_ZEROS_ENCODED,
            sizeof(SHORT_DATA_NO_ZEROS_ENCODED));
}

void test_decode_short_data_one_zero(void)
{
    test_decode(
            SHORT_DATA_ONE_ZERO,
            sizeof(SHORT_DATA_ONE_ZERO),
            SHORT_DATA_ONE_ZERO_ENCODED,
            sizeof(SHORT_DATA_ONE_ZERO_ENCODED));
}

void test_decode_medium_data_several_zeros(void)
{
    test_decode(
            MEDIUM_DATA_SEVERAL_ZEROS,
            sizeof(MEDIUM_DATA_SEVERAL_ZEROS),
            MEDIUM_DATA_SEVERAL_ZEROS_ENCODED,
            sizeof(MEDIUM_DATA_SEVERAL_ZEROS_ENCODED));
}

void test_decode_long_data_no_zeros(void)
{
    test_decode(
            LONG_DATA_NO_ZEROS,
            sizeof(LONG_DATA_NO_ZEROS),
            LONG_DATA_NO_ZEROS_ENCODED,
            sizeof(LONG_DATA_NO_ZEROS_ENCODED));
}

void test_decode_extra_long_data_no_zeros(void)
{
    test_decode(
            EXTRA_LONG_DATA_NO_ZEROS,
            sizeof(EXTRA_LONG_DATA_NO_ZEROS),
            EXTRA_LONG_DATA_NO_ZEROS_ENCODED,
            sizeof(EXTRA_LONG_DATA_NO_ZEROS_ENCODED));
}

void test_decode_invalid_encoding(void)
{
    uint8_t result[sizeof(INVALID_ENCODING)];

    // Encode data.
    uint32_t length = cobs_decode(
            INVALID_ENCODING, sizeof(INVALID_ENCODING), result);

    // Check failure status received.
    TEST_ASSERT_EQUAL_INT32(COBS_DECODE_FAIL, length);
}

/******************************************************************************
 * Static Helper Functions
 ******************************************************************************/

static void test_encode(
        const uint8_t *input_data, uint32_t input_length,
        const uint8_t *expected_data, uint32_t expected_length)
{
    uint8_t result[expected_length];

    // Encode data.
    uint32_t length = cobs_encode(input_data, input_length, result);

    // Check correct length received.
    TEST_ASSERT_EQUAL_INT32(expected_length, length);

    // Check correct data received.
    TEST_ASSERT_EQUAL_HEX8_ARRAY(expected_data, result, expected_length);
}

static void test_decode(
        const uint8_t *expected_data, uint32_t expected_length,
        const uint8_t *input_data, uint32_t input_length)
{
    uint8_t result[expected_length];

    // Encode data.
    uint32_t length = cobs_decode(input_data, input_length, result);

    // Check correct length received.
    TEST_ASSERT_EQUAL_INT32(expected_length, length);

    // Check correct data received.
    TEST_ASSERT_EQUAL_HEX8_ARRAY(expected_data, result, expected_length);
}
